(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{784:function(a,t,s){"use strict";s.r(t);var r=s(4),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[a._v("介绍")]),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("设计模式原则，其实就是程序员在编程时，应当遵守的原则。\n")])])])]),a._v(" "),s("h3",{attrs:{id:"一、设计模式原则介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、设计模式原则介绍"}},[a._v("#")]),a._v(" 一、设计模式原则介绍")]),a._v(" "),s("h4",{attrs:{id:"_1-1-什么是设计模式原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是设计模式原则"}},[a._v("#")]),a._v(" 1.1 什么是设计模式原则")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("设计模式原则，其实就是程序员在编程时，应当遵守的原则。也是各种设计模式的基础（即：**设计模式为什么这么设计的依据**） \n")])])]),s("h3",{attrs:{id:"_1-2-设计模式常用的七大原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-设计模式常用的七大原则"}},[a._v("#")]),a._v(" 1.2 设计模式常用的七大原则")]),a._v(" "),s("ol",[s("li",[a._v("单一职责原则")]),a._v(" "),s("li",[a._v("接口隔离原则")]),a._v(" "),s("li",[a._v("依赖倒置原则")]),a._v(" "),s("li",[a._v("里氏替换原则")]),a._v(" "),s("li",[a._v("开闭原则")]),a._v(" "),s("li",[a._v("迪米特法则")]),a._v(" "),s("li",[a._v("合成复用原则")])]),a._v(" "),s("h3",{attrs:{id:"二、单一职责原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、单一职责原则"}},[a._v("#")]),a._v(" 二、单一职责原则")]),a._v(" "),s("h4",{attrs:{id:"基本介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本介绍"}},[a._v("#")]),a._v(" 基本介绍")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("对类来说的，即一个类应该只负责一项职责。\n")])])]),s("h4",{attrs:{id:"案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[a._v("#")]),a._v(" 案例")]),a._v(" "),s("h4",{attrs:{id:"注意事项及细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项及细节"}},[a._v("#")]),a._v(" 注意事项及细节")]),a._v(" "),s("ul",[s("li",[a._v("降低类的复杂度，一个类只负责一项职责")]),a._v(" "),s("li",[a._v("提高类的可读性，可维护性")]),a._v(" "),s("li",[a._v("降低变更引起的风险")]),a._v(" "),s("li",[a._v("通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单时，才可以在代码级别违反单一职责原则；只有类中方法数量足够少时，可以在方法级别上保持单一职责原则")])]),a._v(" "),s("h3",{attrs:{id:"三、接口隔离原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、接口隔离原则"}},[a._v("#")]),a._v(" 三、接口隔离原则")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("客户端不应该依赖它不需要的接口，即 一个类对另外一个类的依赖应该建立在最小的接口上。\n")])])]),s("h3",{attrs:{id:"四、依赖倒置原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、依赖倒置原则"}},[a._v("#")]),a._v(" 四、依赖倒置原则")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象\n其核心思想是：要面向接口编程，不要面向实现编程\n")])])]),s("h3",{attrs:{id:"五、里氏替换原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、里氏替换原则"}},[a._v("#")]),a._v(" 五、里氏替换原则")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n")])])]),s("h3",{attrs:{id:"六、开闭原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、开闭原则"}},[a._v("#")]),a._v(" 六、开闭原则")]),a._v(" "),s("h3",{attrs:{id:"七、迪米特法则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、迪米特法则"}},[a._v("#")]),a._v(" 七、迪米特法则")]),a._v(" "),s("h3",{attrs:{id:"八、合成复用原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#八、合成复用原则"}},[a._v("#")]),a._v(" 八、合成复用原则")])])}),[],!1,null,null,null);t.default=e.exports}}]);